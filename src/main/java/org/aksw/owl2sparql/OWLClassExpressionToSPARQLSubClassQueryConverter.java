/*
 * #%L
 * owl2sparql-core
 * %%
 * Copyright (C) 2015 AKSW
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package org.aksw.owl2sparql;

import javax.annotation.Nonnull;
import java.io.StringWriter;
import java.io.Writer;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import org.apache.jena.query.Query;
import org.apache.jena.query.QueryFactory;
import org.apache.jena.shared.PrefixMapping;
import org.apache.jena.sparql.algebra.Algebra;
import org.apache.jena.sparql.algebra.Op;
import org.apache.jena.vocabulary.OWL;
import org.apache.jena.vocabulary.RDF;
import org.apache.jena.vocabulary.RDFS;
import org.apache.jena.vocabulary.XSD;
import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.dlsyntax.renderer.DLSyntaxObjectRenderer;
import org.semanticweb.owlapi.formats.TurtleDocumentFormat;
import org.semanticweb.owlapi.io.RDFNode;
import org.semanticweb.owlapi.io.RDFResource;
import org.semanticweb.owlapi.io.RDFResourceIRI;
import org.semanticweb.owlapi.io.ToStringRenderer;
import org.semanticweb.owlapi.model.*;
import org.semanticweb.owlapi.rdf.model.RDFTranslator;
import org.semanticweb.owlapi.rdf.turtle.renderer.TurtleRenderer;
import org.semanticweb.owlapi.util.DefaultPrefixManager;
import org.semanticweb.owlapi.vocab.OWLFacet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OWLClassExpressionToSPARQLSubClassQueryConverter {

	private static final Logger logger = LoggerFactory.getLogger(OWLClassExpressionToSPARQLSubClassQueryConverter.class);

	private final OWLOntologyManager manager;

	private static final PrefixMapping PREFIX_MAPPING_STANDARD = PrefixMapping.Factory.create();
	static {
		PREFIX_MAPPING_STANDARD.setNsPrefix("rdfs", RDFS.getURI());
		PREFIX_MAPPING_STANDARD.setNsPrefix("rdf", RDF.getURI());
		PREFIX_MAPPING_STANDARD.setNsPrefix("owl", OWL.getURI());
		PREFIX_MAPPING_STANDARD.setNsPrefix("xsd", XSD.getURI());
	}
	private static final String PREFIXES_STANDARD = PREFIX_MAPPING_STANDARD.getNsPrefixMap().entrySet().stream()
			.map(e -> String.format("PREFIX %s: <%s>", e.getKey(), e.getValue()))
			.collect(Collectors.joining("\n"));

	private static final String NS = "http://owl2sparql.org/";
	private static final TurtleDocumentFormat TURTLE_FORMAT = new TurtleDocumentFormat();
	static {
		TURTLE_FORMAT.setPrefix("ex", NS);
	}

	/**
	 * Used to generate subclass axiom
	 */
	private static final IRI HELPER_CLASS_IRI = IRI.create("http://owl2sparql.org/a");

	public OWLClassExpressionToSPARQLSubClassQueryConverter() {
		this(OWLManager.createOWLOntologyManager());
	}

	public OWLClassExpressionToSPARQLSubClassQueryConverter(OWLOntologyManager manager) {
		this.manager = manager;
	}

	/**
	 * Converts an OWL class expression to a SPARQL subclass query. That means, the class expression CE and the
	 * projection variable VAR will be converted to
	 * <pre>
	 * SELECT VAR WHERE {
	 *     VAR rdfs:subClassOf T(CE)
	 * }
	 * </pre>
	 * where T(CE) will be the graph pattern generated by converting CE to triple patterns.
	 *
	 * <h3>Example</h3>
	 * <pre>&exist; r.B</pre>
	 * will be converted to
	 * <pre>
	 * PREFIX  rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
	 * PREFIX  rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
	 * PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
	 * PREFIX  ex:  &lt;http://www.example.org#&gt;
	 *
	 * SELECT  ?x
	 * WHERE
	 *   { ?x    rdf:type            owl:Class ;
	 *           rdfs:subClassOf     _:b0 .
	 *     _:b0  rdf:type            owl:Restriction ;
	 *           owl:onProperty      ex:r ;
	 *           owl:someValuesFrom  ex:B
	 *   }
	 *
	 * </pre>
	 *
	 *
	 * <p>Note, due to conversion to Jena Query object, compact syntax formatting of blank nodes is lost.
	 * If necessary, use {@link #convert(OWLClassExpression, String)} instead</p>
	 *
	 * @param ce the OWL class expression
	 * @param targetVar the variable used in projection of the SPARQL query
	 * @return the SPARQL query
	 */
	public Query asQuery(OWLClassExpression ce, String targetVar){
		return QueryFactory.create(convert(ce, targetVar));
	}

	/**
	 * Converts an OWL class expression to a SPARQL subclass query. That means, the class expression CE and the
	 * projection variable VAR will be converted to
	 * <pre>
	 * SELECT VAR WHERE {
	 *     VAR rdfs:subClassOf T(CE)
	 * }
	 * </pre>
	 * where T(CE) will be the graph pattern generated by converting CE to triple patterns.
	 *
	 * <h3>Example</h3>
	 * <pre>&exist; r.B</pre>
	 * will be converted to
	 * <pre>
	 * PREFIX  rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
	 * PREFIX  rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
	 * PREFIX  owl:  &lt;http://www.w3.org/2002/07/owl#&gt;
	 * PREFIX  ex:  &lt;http://www.example.org#&gt;
	 *
	 * SELECT  ?x
	 * WHERE
	 *   { ?x    rdf:type            owl:Class ;
	 *           rdfs:subClassOf     _:b0 .
	 *     _:b0  rdf:type            owl:Restriction ;
	 *           owl:onProperty      ex:r ;
	 *           owl:someValuesFrom  ex:B
	 *   }
	 *
	 * </pre>
	 *
	 *
	 * @param ce the OWL class expression
	 * @param targetVar the variable used in projection of the SPARQL query
	 * @return the SPARQL query
	 */
	public String convert(OWLClassExpression ce, String targetVar){
		StringWriter sw = new StringWriter();
		OWLOntology o = null;
		try {
			o = manager.createOntology();
		} catch (OWLOntologyCreationException e) {
			e.printStackTrace();
		}
		OWLDataFactory df = manager.getOWLDataFactory();

		// generate a subclass axiom A SubClassOf CE
		o.addAxiom(df.getOWLSubClassOfAxiom(df.getOWLClass(HELPER_CLASS_IRI), ce));

		// render the axiom
		SPARQLRenderer r = new SPARQLRenderer(o, sw, TURTLE_FORMAT, HELPER_CLASS_IRI);
		r.render();
		sw.flush();
		String graphPattern = sw.toString();

		// replace the subclass by the given SPARQL target variable used in projection
		graphPattern = graphPattern
				.replace(TURTLE_FORMAT.getPrefixIRI(HELPER_CLASS_IRI), "  " + targetVar)
				.replaceAll("(?m)^[ \t]*\r?\n", "");

		// build the query
		StringBuilder sb = new StringBuilder(PREFIXES_STANDARD);
		sb.append(String.format("\nSELECT %s WHERE {", targetVar));
		sb.append(graphPattern);
		sb.append("}");

		return sb.toString();
	}

	public static void main(String[] args) throws Exception {
		ToStringRenderer.setRenderer(DLSyntaxObjectRenderer::new);

		OWLOntologyManager man = OWLManager.createOWLOntologyManager();
		OWLOntology ontology = man.createOntology();
		OWLDataFactory df = man.getOWLDataFactory();
		PrefixManager pm = new DefaultPrefixManager();
		pm.setDefaultPrefix("http://dbpedia.org/ontology/");

		OWLClass clsA = df.getOWLClass("A", pm);
		OWLClass clsB = df.getOWLClass("B", pm);
		OWLClass clsC = df.getOWLClass("C", pm);

		OWLObjectProperty propR = df.getOWLObjectProperty("r", pm);
		OWLObjectProperty propS = df.getOWLObjectProperty("s", pm);

		OWLDataProperty dpT = df.getOWLDataProperty("t", pm);
		OWLDataRange booleanRange = df.getBooleanOWLDatatype();
		OWLLiteral lit = df.getOWLLiteral(1);

		OWLIndividual indA = df.getOWLNamedIndividual("a", pm);
		OWLIndividual indB = df.getOWLNamedIndividual("b", pm);

		String rootVar = "?x";

		OWLClassExpressionToSPARQLSubClassQueryConverter converter = new OWLClassExpressionToSPARQLSubClassQueryConverter(man);

		OWLClassExpression expr = clsA;
		String query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectSomeValuesFrom(propR, clsB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				df.getOWLObjectSomeValuesFrom(propR, clsB),
				clsB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectUnionOf(
				clsA,
				clsB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectHasValue(propR, indA);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(propR, df.getOWLThing());
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(propR, df.getOWLObjectAllValuesFrom(propS, df.getOWLThing()));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(
				propR,
				df.getOWLObjectIntersectionOf(
						clsA,
						df.getOWLObjectAllValuesFrom(propS, df.getOWLThing())));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(
				propR,
				df.getOWLObjectUnionOf(
						clsA,
						df.getOWLObjectAllValuesFrom(propS, df.getOWLThing())));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(propR, clsB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectAllValuesFrom(df.getOWLObjectProperty("language", pm), df.getOWLClass("Language", pm));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectMinCardinality(2, df.getOWLObjectProperty("language", pm), df.getOWLClass("Language", pm));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				df.getOWLClass("Place", pm),
				df.getOWLObjectMinCardinality(
						2,
						df.getOWLObjectProperty("language", pm),
						df.getOWLClass("Language", pm)));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectOneOf(indA, indB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectSomeValuesFrom(propR, df.getOWLObjectOneOf(indA, indB));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLObjectHasSelf(propR));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLDataSomeValuesFrom(dpT, booleanRange));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLDataHasValue(dpT, lit));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLDataMinCardinality(2, dpT, booleanRange));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectComplementOf(clsB);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLObjectComplementOf(clsB));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectSomeValuesFrom(propR,
				df.getOWLObjectIntersectionOf(
						clsA,
						df.getOWLObjectComplementOf(clsB)));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLDataAllValuesFrom(dpT, booleanRange);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLDataAllValuesFrom(dpT,df.getOWLDataOneOf(lit));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				df.getOWLObjectComplementOf(clsA),
				df.getOWLObjectSomeValuesFrom(
						propR,
						df.getOWLObjectSomeValuesFrom(
								propS,
								df.getOWLObjectComplementOf(clsB)
						)
				)
		);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectUnionOf(
				df.getOWLObjectComplementOf(clsA),
				df.getOWLObjectComplementOf(clsB)
		);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLObjectUnionOf(
						clsB,
						df.getOWLObjectComplementOf(
								df.getOWLObjectSomeValuesFrom(
										propR,
										df.getOWLThing()
								)
						)
				)
		);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		Op op = Algebra.compile(converter.asQuery(expr, rootVar));
		System.out.println(op.toString());

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLObjectComplementOf(
						df.getOWLObjectSomeValuesFrom(
								propR,
								clsB
						)
				)
		);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		expr = df.getOWLObjectIntersectionOf(
				clsA,
				df.getOWLDataSomeValuesFrom(dpT, df.getOWLDataComplementOf(booleanRange))
		);
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data one of
		expr = df.getOWLDataSomeValuesFrom(dpT,df.getOWLDataOneOf(df.getOWLLiteral(1), df.getOWLLiteral(2)));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data not one of
		expr = df.getOWLDataSomeValuesFrom(
				dpT,
				df.getOWLDataComplementOf(
						df.getOWLDataOneOf(df.getOWLLiteral(1), df.getOWLLiteral(2))));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data intersection
		expr = df.getOWLDataSomeValuesFrom(
				dpT,
				df.getOWLDataIntersectionOf(
						df.getBooleanOWLDatatype(),
						df.getOWLDataOneOf(df.getOWLLiteral(1), df.getOWLLiteral(2))));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data union
		expr = df.getOWLDataSomeValuesFrom(
				dpT,
				df.getOWLDataUnionOf(
						df.getIntegerOWLDatatype(),
						df.getOWLDataIntersectionOf(
								df.getBooleanOWLDatatype(),
								df.getOWLDataOneOf(df.getOWLLiteral(1), df.getOWLLiteral(2)))));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data restriction
		expr = df.getOWLDataSomeValuesFrom(
				dpT,
				df.getOWLDatatypeRestriction(
						df.getIntegerOWLDatatype(),
						df.getOWLFacetRestriction(
								OWLFacet.MAX_EXCLUSIVE, df.getOWLLiteral(10)),
						df.getOWLFacetRestriction(
								OWLFacet.MIN_INCLUSIVE, df.getOWLLiteral(3))));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);

		// data restriction
		expr = df.getOWLDataSomeValuesFrom(
				dpT,
				df.getOWLDatatypeRestriction(
						df.getRDFPlainLiteral(),
						df.getOWLFacetRestriction(
								OWLFacet.LENGTH, df.getOWLLiteral(10))));
		query = converter.asQuery(expr, rootVar).toString();
		System.out.println(expr + "\n" + query);
	}

	/**
	 * Helper class to render OWL class expression as Turtle in a SPARQL graph pattern.
	 *
	 * @author Lorenz Buehmann
	 */
	private static class SPARQLRenderer extends TurtleRenderer {
		private final IRI target;

		SPARQLRenderer(OWLOntology ontology, Writer writer, OWLDocumentFormat format, IRI target) {
			super(ontology, writer, format);
			this.target = target;
		}
		@Override
		protected void render(RDFResource node, boolean root) {
			if(!root || node.getIRI().equals(target))
				super.render(node, root);
		}
		@Override
		protected void writeBanner(String name) {}
		@Override
		protected void beginDocument() {}
		@Override
		protected void endDocument() {}
		@Override
		protected void writeClassComment(OWLClass cls) {}
		@Override
		protected void writeDataPropertyComment(OWLDataProperty prop) {}
		@Override
		protected void writeObjectPropertyComment(OWLObjectProperty prop) {}
		@Override
		protected void writeIndividualComments(OWLNamedIndividual ind) {}
		@Override
		protected void writeDatatypeComment(OWLDatatype datatype) {}
		@Override
		protected void writeAnnotationPropertyComment(OWLAnnotationProperty prop) {}
	}

	private static class ClassExpressionToRDFTranslator
			extends RDFTranslator {

		private final OWLOntologyManager manager;
		private final OWLOntology ontology;

		private StringBuilder sb;

		private static final PrefixMapping PREFIX_MAPPING_STANDARD = PrefixMapping.Standard;
		private static final String PREFIXES_STANDARD = PREFIX_MAPPING_STANDARD.getNsPrefixMap().entrySet().stream()
				.map(e -> String.format("PREFIX %s: <%s>", e.getKey(), e.getValue()))
				.collect(Collectors.joining("\n"));

		private static final String NS = "http://owl2sparql.org/";
		/**
		 * Used to generate subclass axiom
		 */
		private static final IRI HELPER_CLASS_IRI = IRI.create("http://owl2sparql.org/a");

		ClassExpressionToRDFTranslator(OWLOntologyManager manager,
									   OWLOntology ontology,
									   boolean useStrongTyping) {
			super(manager, ontology, useStrongTyping, i -> false, ax -> false, new AtomicInteger());
			this.manager = manager;
			this.ontology = ontology;
		}


		/**
		 * Converts an OWL class expression to a SPARQL query graph pattern that can be used as the object of
		 * a SPARQL triple pattern.
		 *
		 * @param ce the OWL class expression
		 * @return the SPARQL query graph pattern
		 */
		public String convert(OWLClassExpression ce, String targetVar) {
			sb = new StringBuilder(PREFIXES_STANDARD);
			sb.append(String.format("\nSELECT %s WHERE {", targetVar));
			ce.accept(this);
			sb.append("}");
			return sb.toString();
		}

		@Override
		protected void addTriple(@Nonnull RDFResource subject, @Nonnull RDFResourceIRI pred,
								 @Nonnull RDFNode object) {
			sb.append(subject).append(" ").append(pred).append(" ").append(object).append(" .\n");
		}
	}
}